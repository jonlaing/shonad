import * as Maybe from "./Maybe";
export declare const concat: <A>(as: A[][]) => A[];
export declare const head: <A>(a: A[]) => Maybe.Maybe<A>;
export declare const reverse: <A>(a: A[]) => A[];
export declare const last: <A>(a: A[]) => Maybe.Maybe<A>;
export declare const tail: <A>(a: A[]) => Maybe.Maybe<A[]>;
export declare const init: <A>(a: A[]) => Maybe.Maybe<A[]>;
export declare const uncons: <A>(as: A[]) => Maybe.Maybe<[A, A[]]>;
export declare const singleton: <A>(a: A) => A[];
export declare const isEmpty: <A>(a: A[]) => boolean;
export declare const length: <A>(a: A[]) => number;
export declare function intersperse<A>(a: A): (as: A[]) => A[];
export declare function intersperse<A>(a: A, as: A[]): A[];
export declare function intercalate<A>(a: A): (as: A[][]) => A[];
export declare function intercalate<A>(a: A, as: A[][]): A[];
export declare function find<A>(pred: (x: A) => boolean): (xs: A[]) => Maybe.Maybe<A>;
export declare function find<A>(pred: (x: A) => boolean, xs: A[]): Maybe.Maybe<A>;
export declare function nth<A>(i: number): (xs: A[]) => Maybe.Maybe<A>;
export declare function nth<A>(i: number, xs: A[]): Maybe.Maybe<A>;
export declare function take<A>(i: number): (xs: A[]) => A[];
export declare function take<A>(i: number, xs: A[]): A[];
export declare function takeLast<A>(i: number): (xs: A[]) => A[];
export declare function takeLast<A>(i: number, xs: A[]): A[];
export declare function splitAt<A>(i: number): (xs: A[]) => [A[], A[]];
export declare function splitAt<A>(i: number, xs: A[]): [A[], A[]];
export declare function adjust<A>(f: (a: A) => A): (i: number, xs: A[]) => A[];
export declare function adjust<A>(f: (a: A) => A, i: number): (xs: A[]) => A[];
export declare function adjust<A>(f: (a: A) => A, i: number, xs: A[]): A[];
export declare function update<A>(x: A): (i: number, xs?: A[]) => A[];
export declare function update<A>(x: A, i: number): (xs: A[]) => A[];
export declare function update<A>(x: A, i: number, xs: A[]): A[];
