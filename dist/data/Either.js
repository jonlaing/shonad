"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&("get"in desc?m.__esModule:!desc.writable&&!desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){o[k2=void 0===k2?k:k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result};Object.defineProperty(exports,"__esModule",{value:!0}),exports._do=exports.bind=exports.apply_=exports.apply=exports.pure=exports.fmap=exports.unwrap=exports.equals=exports.eitherNil=exports.fromMaybe=exports.partitionEithers=exports.fromRight=exports.fromLeft=exports.rights=exports.lefts=exports.either=exports.isRight=exports.isLeft=exports.right=exports.left=exports.Right=exports.Left=exports.Either=void 0;const Monad_1=require("../control/Monad"),Fn=__importStar(require("../base/Function")),Maybe=__importStar(require("./Maybe")),Util=__importStar(require("../base/Util"));class Either extends Monad_1.Monad{static pure(a){return new Right(a)}}class Left extends(exports.Either=Either){constructor(){super(...arguments),this.isLeft=Fn.always(!0),this.isRight=Fn.always(!1),this.fmap=f=>this,this.apply=ma=>this,this.bind=f=>this,this.unwrap=fallback=>fallback,this.equals=Fn.always(!1)}}exports.Left=Left;class Right extends Either{constructor(){super(...arguments),this.isLeft=Fn.always(!1),this.isRight=Fn.always(!0),this.fmap=f=>new Right(f(this.val)),this.apply=ma=>ma.fmap(this.val),this.bind=f=>f(this.val),this.unwrap=fallback=>this.val,this.equals=b=>this.fmap(Util.eq(b)).unwrap(!1)}}exports.Right=Right;const left=a=>new Left(a),right=(exports.left=left,b=>new Right(b)),isLeft=(exports.right=right,x=>x.isLeft()),isRight=(exports.isLeft=isLeft,x=>x.isRight()),lefts=(exports.isRight=isRight,exports.either=Fn.curry((f0,f1,x)=>((0,exports.isLeft)(x)?f0:f1)(x.val)),xs=>xs.reduce((acc,x)=>(0,exports.isLeft)(x)?[...acc,x.val]:acc,[])),rights=(exports.lefts=lefts,xs=>xs.reduce((acc,x)=>(0,exports.isRight)(x)?[...acc,x.val]:acc,[])),partitionEithers=(exports.rights=rights,exports.fromLeft=Fn.curry((fallback,x)=>(0,exports.isLeft)(x)?x.val:fallback),exports.fromRight=Fn.curry((fallback,x)=>(0,exports.isRight)(x)?x.val:fallback),xs=>xs.reduce((acc,x)=>(0,exports.isLeft)(x)?[[...acc[0],x.val],acc[1]]:[acc[0],[...acc[1],x.val]],[[],[]]));exports.partitionEithers=partitionEithers,exports.fromMaybe=Fn.curry((error,m)=>Maybe.isNothing(m)?(0,exports.left)(error):(0,exports.right)(m.val)),exports.eitherNil=Fn.curry((error,x)=>Util.isNil(x)?(0,exports.left)(error):(0,exports.right)(x)),exports.equals=Fn.curry((a,mx)=>(0,exports.fromRight)(!1,(0,exports.fmap)(Util.eq(a),mx))),exports.unwrap=Fn.curry((fallback,e)=>e.unwrap(fallback)),exports.fmap=Either.fmap,exports.pure=Either.pure,exports.apply=Either.apply,exports.apply_=Fn.flip(exports.apply),exports.bind=Either.bind,exports._do=(0,Monad_1.makeDo)(exports.pure,exports.bind);
//# sourceMappingURL=Either.js.map