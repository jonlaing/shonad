"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&("get"in desc?m.__esModule:!desc.writable&&!desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){o[k2=void 0===k2?k:k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result};Object.defineProperty(exports,"__esModule",{value:!0}),exports._do=exports.unwrap=exports.or=exports.equals=exports.maybeRecord=exports.mapMaybe=exports.catMaybes=exports.maybeToList=exports.listToMaybe=exports.maybeNil=exports.fromMaybe=exports.maybe=exports.isNothing=exports.isJust=exports.nothing=exports.just=exports.Nothing=exports.Just=exports.pure=exports.bind=exports.apply_=exports.apply=exports.fmap=exports.Maybe=void 0;const Monad_1=require("../control/Monad"),Fn=__importStar(require("../base/Function")),Util=__importStar(require("../base/Util"));class Maybe extends Monad_1.Monad{static pure(a){return new Just(a)}}exports.Maybe=Maybe,exports.fmap=Maybe.fmap,exports.apply=Maybe.apply,exports.apply_=Fn.flip(Maybe.apply),exports.bind=Maybe.bind,exports.pure=Maybe.pure;class Just extends Maybe{constructor(){super(...arguments),this.isJust=Fn.always(!0),this.isNothing=Fn.always(!1),this.fmap=f=>new Just(f(this.val)),this.apply=ma=>(0,exports.isJust)(ma)?ma.fmap(this.val):(0,exports.nothing)(),this.bind=f=>f(this.val),this.unwrap=fallback=>this.val,this.equals=a=>this.fmap(Util.eq(a)).unwrap(!1)}}exports.Just=Just;class Nothing extends Maybe{constructor(){super(...arguments),this.isJust=Fn.always(!1),this.isNothing=Fn.always(!0),this.fmap=f=>new Nothing(this.val),this.apply=f=>this,this.bind=f=>this,this.unwrap=fallback=>fallback,this.equals=Fn.always(!1)}}exports.Nothing=Nothing;const just=x=>new Just(x),nothing=(exports.just=just,x=>new Nothing(x)),isJust=(exports.nothing=nothing,x=>x.isJust()),isNothing=(exports.isJust=isJust,x=>x.isNothing()),maybeNil=(exports.isNothing=isNothing,exports.maybe=Fn.curry((fallback,f,x)=>(0,exports.isJust)(x)?f(x.val):fallback),exports.fromMaybe=Fn.curry((fallback,x)=>(0,exports.isJust)(x)?x.val:fallback),a=>(Util.isNil(a)?(0,exports.nothing):(0,exports.just))(a)),listToMaybe=(exports.maybeNil=maybeNil,a=>0<a.length?(0,exports.just)(a[0]):(0,exports.nothing)()),maybeToList=(exports.listToMaybe=listToMaybe,ma=>ma.fmap(a=>[a]).unwrap([])),catMaybes=(exports.maybeToList=maybeToList,xs=>xs.reduce((acc,x)=>(0,exports.isJust)(x)?[...acc,x.val]:acc,[])),maybeRecord=(exports.catMaybes=catMaybes,exports.mapMaybe=Fn.curry((f,as)=>as.reduce((acc,a)=>{a=f(a);return(0,exports.isJust)(a)?[...acc,a.val]:acc},[])),x=>Object.keys(x).reduce((acc,k)=>Object.assign(Object.assign({},acc),{[k]:(0,exports.maybeNil)(x[k])}),{}));exports.maybeRecord=maybeRecord,exports.equals=Fn.curry((a,mx)=>(0,exports.fromMaybe)(!1,(0,exports.fmap)(Util.eq(a),mx))),exports.or=Fn.curry((f1,f0)=>{f0=f0();return(0,exports.isJust)(f0)?f0:f1()}),exports.unwrap=Fn.curry((fallback,mx)=>mx.unwrap(fallback)),exports._do=(0,Monad_1.makeDo)(exports.pure,exports.bind);
//# sourceMappingURL=Maybe.js.map